function GsTabQueue(e,t){return function(){"use strict";const o="queued",r="inProgress",n="sleeping",u="timeout",i={concurrentExecutors:1,jobTimeout:1e3,processingDelay:500,executorFn:(e,t,o,r)=>t(!0),exceptionFn:(e,t,o,r)=>t(!1)},s={},c=[];let l=null,a=e;function f(e){for(const t of Object.keys(e))i[t]=e[t];if(!m(i.concurrentExecutors,1))throw new Error("concurrentExecutors must be an integer greater than 0");if(!m(i.jobTimeout,1))throw new Error("jobTimeout must be an integer greater than 0");if(!m(i.processingDelay,0))throw new Error("processingDelay must be an integer of at least 0");if("function"!=typeof i.executorFn)throw new Error("executorFn must be a function");if("function"!=typeof i.exceptionFn)throw new Error("executorFn must be a function")}function m(e,t){return null!==e&&!isNaN(Number(e)&&e>=t)}function b(e,t){t=t||{};for(const o in t)e.executionProps[o]=t[o]}function d(e){const t=e.tab;delete s[t.id];for(const[e,o]of c.entries())if(o===t.id){c.splice(e,1);break}gsUtils.log(a,`total queue size: ${c.length}`)}function g(){let e,t;const o=new Promise(((o,r)=>{e=o,t=r}));return o.resolve=t=>(e(t),o),o.reject=e=>(t(e),o),o}function T(e){setTimeout((()=>{null===l&&(l=setTimeout((()=>{l=null,function(){let e=0;for(const t of c){const n=s[t];if(n.status===r?e+=1:n.status===o?(p(n),e+=1):n.status,e>=i.concurrentExecutors)break}}()}),50))}),e)}function p(e){e.status=r,gsUtils.log(e.tab.id,a,"Executing executorFn for tab.");const t=t=>function(e,t){if(!s[e.tab.id])return;gsUtils.log(e.tab.id,a,"Queued tab resolved. Result: ",t),clearTimeout(e.timeoutTimer),d(e),e.deferredPromise.resolve(t),T(i.processingDelay)}(e,t),o=t=>x(e,t),n=(t,o)=>{!function(e,t,o){t=t||5e3,o&&b(e,o);e.requeues+=1,gsUtils.log(e.tab.id,a,`Requeueing tab. Requeues: ${e.requeues}`),P(e,t),T(i.processingDelay)}(e,t,o)};e.hasOwnProperty("timeoutTimer")||(e.timeoutTimer=setTimeout((()=>{gsUtils.log(e.tab.id,a,"Tab job timed out"),i.exceptionFn(e.tab,e.executionProps,u,t,o,n)}),i.jobTimeout)),i.executorFn(e.tab,e.executionProps,t,o,n)}function x(e,t){s[e.tab.id]&&(gsUtils.log(e.tab.id,a,"Queued tab rejected. Error: ",t),clearTimeout(e.timeoutTimer),d(e),e.deferredPromise.reject(t),T(i.processingDelay))}function P(e,t){e.status=n,e.sleepTimer&&clearTimeout(e.sleepTimer),e.sleepTimer=window.setTimeout((()=>{delete e.sleepTimer,e.status=o,T(0)}),t)}return f(t),{EXCEPTION_TIMEOUT:u,setQueueProperties:f,getQueueProperties:function(){return i},getTotalQueueSize:function(){return Object.keys(s).length},queueTabAsPromise:function(e,t,r){t=t||{};let n=s[e.id];return n?(n.tab=e,b(n,t),gsUtils.log(e.id,a,"Tab already queued.")):(n={tab:e,executionProps:t,deferredPromise:g(),status:o,requeues:0},function(e){const t=e.tab;s[t.id]=e,c.push(t.id)}(n)),r&&m(r,1)?(gsUtils.log(e.id,a,`Sleeping tab for ${r}ms`),P(n,r)):(n.sleepTimer&&(gsUtils.log(e.id,a,"Removing tab from sleep"),clearTimeout(n.sleepTimer),delete n.sleepTimer,n.status=o),T(0)),n.deferredPromise},unqueueTab:function(e){const t=s[e.id];return!!t&&(clearTimeout(t.timeoutTimer),d(t),x(t,"Queued tab job cancelled externally"),!0)},getQueuedTabDetails:function(e){return s[e.id]}}}()}